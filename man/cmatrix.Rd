% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cmatrix}
\alias{cmatrix}
\title{Confusion Matrix}
\usage{
cmatrix(
  actual,
  predicted
)
}
\arguments{
\item{actual}{A <\link{factor}>-vector of \link{length} \eqn{n}, and \eqn{k} levels.}

\item{predicted}{A <\link{factor}>-vector of \link{length} \eqn{n}, and \eqn{k} levels.}
}
\value{
A named \eqn{k} x \eqn{k} <\link{matrix}> of \link{class} \if{html}{\out{<cmatrix>}}
}
\description{
The \code{\link[=cmatrix]{cmatrix()}}-function uses cross-classifying factors to build
a confusion matrix of the counts at each combination of the \link{factor} levels.
Each row of the \link{matrix} represents the actual \link{factor} levels, while each
column represents the predicted \link{factor} levels.
}
\details{
Consider a classification problem with three classes: \code{A}, \code{B}, and \code{C}. The actual vector of \code{\link[=factor]{factor()}} values is defined as follows:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{## set seed
set.seed(1903)

## actual
factor(
  x = sample(x = 1:3, size = 10, replace = TRUE),
  levels = c(1, 2, 3),
  labels = c("A", "B", "C")
)
#>  [1] B A B B A C B C C A
#> Levels: A B C
}\if{html}{\out{</div>}}

Here, the values 1, 2, and 3 are mapped to \code{A}, \code{B}, and \code{C}, respectively. Now, suppose your model does not predict any \code{B}'s. The predicted vector of \code{\link[=factor]{factor()}} values would be defined as follows:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{## set seed
set.seed(1903)

## predicted
factor(
  x = sample(x = c(1, 3), size = 10, replace = TRUE),
  levels = c(1, 2, 3),
  labels = c("A", "B", "C")
)
#>  [1] C A C C C C C C A C
#> Levels: A B C
}\if{html}{\out{</div>}}

In both cases, \eqn{k = 3}, determined indirectly by the \code{levels} argument.
}
\section{Dimensions}{


There is no robust defensive measure against misspecififying
the confusion matrix. If the arguments are correctly specified, the resulting
confusion matrix is on the form:\tabular{lcr}{
    \tab A (Predicted) \tab B (Predicted) \cr
   A (Actual) \tab Value \tab Value \cr
   B (Actual) \tab Value \tab Value \cr
}
}

\examples{
# 1) recode Iris
# to binary classification
# problem
iris$Species <- factor(
  x = as.numeric(
    iris$Species == "virginica"
  ),
  levels = c(1,0),
  labels = c("virginica", "others")
)

# 2) fit the logistic
# regression
model <- glm(
  formula = Species ~ Sepal.Length + Sepal.Width,
  data    = iris,
  family = binomial(
    link = "logit"
  )
)

# 3) generate predicted
# classes
predicted <- as.factor(
  ifelse(
    predict(model, type = "response") > 0.5,
    yes = "virginica",
    no  = "others"
  )
)

# 4) confusion matrix
# and print
print(
  confusion_matrix <- cmatrix(
    actual    = iris$Species,
    predicted = predicted
  )
)

# 5) summary of the matrix
summary(
  confusion_matrix
)

# 6) visualize the matrix
plot(
  confusion_matrix
)

}
\seealso{
Other classification: 
\code{\link{accuracy.factor}()},
\code{\link{baccuracy.factor}()},
\code{\link{dor}()},
\code{\link{fbeta.factor}()},
\code{\link{fdr}()},
\code{\link{fer}()},
\code{\link{fmi}()},
\code{\link{fpr}()},
\code{\link{jaccard}()},
\code{\link{kappa}()},
\code{\link{mcc}()},
\code{\link{nlr}()},
\code{\link{npv}()},
\code{\link{plr}()},
\code{\link{precision.factor}()},
\code{\link{recall.factor}()},
\code{\link{specificity.factor}()},
\code{\link{zerooneloss}()}
}
\concept{classification}
