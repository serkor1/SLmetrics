% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{fbeta}
\alias{fbeta}
\title{\eqn{F_{\beta}}-score}
\usage{
# fbeta-score
fbeta(
  actual,
  predicted,
  beta = 1,
  aggregate = FALSE
)
}
\arguments{
\item{actual}{A <\link{factor}>-vector of \link{length} \eqn{n}, and \eqn{k} levels.}

\item{predicted}{A <\link{factor}>-vector of \link{length} \eqn{n}, and \eqn{k} levels.}

\item{beta}{A <\link{numeric}> vector of length 1. 1 by default, see details.}

\item{aggregate}{A <\link{logical}>-value of \link{length} 1. \link{FALSE} by default. If \link{TRUE} it returns the
micro average across all k-classes}
}
\value{
If \code{aggregate} is \link{FALSE} (the default), a named <\link{numeric}>-vector of \link{length} k

If \code{aggregate} is \link{TRUE}, a <\link{numeric}>-vector of \link{length} 1
}
\description{
The \code{\link[=fbeta]{fbeta()}}-function computes the \href{https://en.wikipedia.org/wiki/F1_score}{F-beta score}, a weighted harmonic mean of precision and recall, between
two vectors of predicted and observed \code{\link[=factor]{factor()}} values. The parameter \eqn{\beta} determines the weight of precision and recall in the combined score. When \code{aggregate = TRUE}, the function returns the micro-average F-beta score across all classes \eqn{k}.
By default, it returns the class-wise F-beta score.
}
\details{
Consider a classification problem with three classes: \code{A}, \code{B}, and \code{C}. The actual vector of \code{\link[=factor]{factor()}} values is defined as follows:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{## actual
factor(
  x = sample(x = 1:3, size = 10, replace = TRUE),
  levels = c(1, 2, 3),
  labels = c("A", "B", "C")
)
#>  [1] B B C B C B B A A B
#> Levels: A B C
}\if{html}{\out{</div>}}

Here, the values 1, 2, and 3 are mapped to \code{A}, \code{B}, and \code{C}, respectively. Now, suppose your model does not predict any \code{B}'s. The predicted vector of \code{\link[=factor]{factor()}} values would be defined as follows:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{## predicted
factor(
  x = sample(x = c(1, 3), size = 10, replace = TRUE),
  levels = c(1, 2, 3),
  labels = c("A", "B", "C")
)
#>  [1] C A C A C C A C C C
#> Levels: A B C
}\if{html}{\out{</div>}}

In both cases, \eqn{k = 3}, determined indirectly by the \code{levels} argument.
}
\section{Calculation}{


The F-beta score is a weighted harmonic mean of precision and recall, calculated for each class \eqn{k} as follows,

\deqn{
  (1 + \beta^2) \cdot \frac{\text{Precision}_k \cdot \text{Recall}_k}{(\beta^2 \cdot \text{Precision}_k) + \text{Recall}_k}
}

Where precision is \eqn{\frac{\#TP_k}{\#TP_k + \#FP_k}} and recall (sensitivity) is \eqn{\frac{\#TP_k}{\#TP_k + \#FN_k}}, and \eqn{\beta} determines the weight of precision relative to recall.

When \code{aggregate = TRUE}, the \code{micro}-average F-beta score is calculated,

\deqn{
  (1 + \beta^2) \cdot \frac{\sum_{k=1}^K \text{Precision}_k \cdot \sum_{k=1}^K \text{Recall}_k}{(\beta^2 \cdot \sum_{k=1}^K \text{Precision}_k) + \sum_{k=1}^K \text{Recall}_k}
}
}

\examples{
# 1) recode Iris
# to binary classification
# problem
iris$Species <- factor(
  x = as.numeric(
    iris$Species == "virginica"
  ),
  levels = c(1,0),
  labels = c("virginica", "others")
)

# 2) fit the logistic
# regression
model <- glm(
  formula = Species ~ Sepal.Length + Sepal.Width,
  data    = iris,
  family = binomial(
    link = "logit"
  )
)

# 3) generate predicted
# classes
predicted <- as.factor(
  ifelse(
    predict(model, type = "response") > 0.5,
    yes = "virginica",
    no  = "others"
  )
)

# 4) F1-score for each
# class
fbeta(
  actual    = iris$Species,
  predicted = predicted
)

# 4.1) micro-averaged F1 score
fbeta(
  actual    = iris$Species,
  predicted = predicted,
  aggregate = TRUE
)

# 4.2 macro-averaged F1 score
mean(
  fbeta(
    actual    = iris$Species,
    predicted = predicted
  )
)

# 5) F-score each class
# with beta 2
fbeta(
  actual    = iris$Species,
  predicted = predicted,
  beta      = 2
)

# 4.1) micro-averaged F-score
# with beta 2
fbeta(
  actual    = iris$Species,
  predicted = predicted,
  beta      = 2,
  aggregate = TRUE
)

# 4.2 macro-averaged F-score
# with beta 2
mean(
  fbeta(
    actual    = iris$Species,
    predicted = predicted,
    beta      = 2
  )
)
}
\seealso{
Other classification: 
\code{\link{accuracy}()},
\code{\link{cmatrix}()},
\code{\link{dor}()},
\code{\link{fdr}()},
\code{\link{fer}()},
\code{\link{fmi}()},
\code{\link{fpr}()},
\code{\link{jaccard}()},
\code{\link{kappa}()},
\code{\link{mcc}()},
\code{\link{nlr}()},
\code{\link{npv}()},
\code{\link{plr}()},
\code{\link{precision}()},
\code{\link{recall}()},
\code{\link{specificity}()},
\code{\link{zerooneloss}()}
}
\concept{classification}
