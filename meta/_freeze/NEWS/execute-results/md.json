{
  "hash": "d3ff8fcc0ca057d31e27dfb777351754",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat:\n    gfm:\n        default-image-extension: \".png\"\n        toc: true\nalways_allow_html: true\nexecute:\n  cache: true\n  freeze: auto\n  dir: meta\nknitr:\n  opts_chunk:\n    collapse: true\n    comment: \"#>\"\n    dpi: 1280\n    fig.height: 6\n    out.width: 100%\n---\n\n\n\n> Version 0.3-3 is considered pre-release of {SLmetrics}. We do not\n> expect any breaking changes, unless a major bug/issue is reported and its nature\n> forces breaking changes.\n\n\n\n\n# :bookmark: Version 0.3-3\n\n## :sparkles: Improvements\n\n- **S3 signatures:** All S3-methods now have a generic signature, the\n  functions should now be easier to navigate in argument-wise.\n\n- **Exported Data:** Three new datasets have been introduced to the\n  package; the [Wine\n  Quality](https://archive.ics.uci.edu/dataset/186/wine+quality)-,\n  [Obesity](https://archive.ics.uci.edu/dataset/544/estimation+of+obesity+levels+based+on+eating+habits+and+physical+condition)-\n  and [Banknote\n  Authentication](https://archive.ics.uci.edu/dataset/267/banknote+authentication)\n  datasets. Each dataset is comes in named `list` where features and\n  targets are stored separately. Below is an example from the Obesity\n  dataset:\n\n``` r\n## 1) summarise the\n## list\nsummary(SLmetrics::obesity)\n#>          Length Class      Mode\n#> features 15     data.frame list\n#> target    2     -none-     list\n\n## 2) head the featues\nhead(SLmetrics::obesity$features)\n#>        caec       calc                mtrans family_history_with_overweight\n#> 1 sometimes         no public_transportation                              1\n#> 2 sometimes  sometimes public_transportation                              1\n#> 3 sometimes frequently public_transportation                              1\n#> 4 sometimes frequently               walking                              0\n#> 5 sometimes  sometimes public_transportation                              0\n#> 6 sometimes  sometimes            automobile                              0\n#>   favc smoke scc male age height fcvc ncp ch2o faf tue\n#> 1    0     0   0    0  21   1.62    2   3    2   0   1\n#> 2    0     1   1    0  21   1.52    3   3    3   3   0\n#> 3    0     0   0    1  23   1.80    2   3    2   2   1\n#> 4    0     0   0    1  27   1.80    3   3    2   2   0\n#> 5    0     0   0    1  22   1.78    2   1    2   0   0\n#> 6    1     0   0    1  29   1.62    2   3    2   0   0\n\n## 3) head target\n## variables\nhead(SLmetrics::obesity$target$class)\n#> [1] Normal_Weight       Normal_Weight       Normal_Weight      \n#> [4] Overweight_Level_I  Overweight_Level_II Normal_Weight      \n#> 7 Levels: Insufficient_Weight Normal_Weight Obesity_Type_I ... Overweight_Level_II\nhead(SLmetrics::obesity$target$regression)\n#> [1] 64.0 56.0 77.0 87.0 89.8 53.0\n```\n\n### :rocket: New features\n\n#### New metrics\n\n- **Poisson LogLoss:** The logloss for count data has been implemented.\n  This metric shares the method of logloss and can be used as follows:\n\n``` r\n## 1) define observed integers\n## and response probabilities\nactual   <- as.integer(factor(c(\"Class A\", \"Class B\", \"Class A\")))\nweights  <- c(0.3,0.9,1) \nresponse <- matrix(cbind(\n    0.2, 0.8,\n    0.8, 0.2,\n    0.7, 0.3\n),nrow = 3, ncol = 2)\n\n## 2) weighted\n## and unweighted poisson\n## distributed log-loss\ncat(\n    \"Unweighted Poisson Log Loss:\",\n    SLmetrics::logloss(\n        actual,\n        response\n    ),\n    \"Weighted Poisson Log Loss:\",\n    SLmetrics::weighted.logloss(\n        actual   = actual,\n        response = response,\n        w        = weights\n    ),\n    sep = \"\\n\"\n)\n#> Unweighted Poisson Log Loss:\n#> 1.590672\n#> Weighted Poisson Log Loss:\n#> 1.505212\n```\n\n- **Area under the Curve:** A new set of functions have been introduced\n  which calculates the weighted and unweighted area under the\n  Precision-Recall and Receiver Operator Characteristics curve. See\n  below:\n\n``` r\n## 1) define observed integers\n## and response probabilities\nactual   <- factor(c(\"Class A\", \"Class B\", \"Class A\"))\nweights  <- c(0.3,0.9,1) \nresponse <- matrix(cbind(\n    0.2, 0.8,\n    0.8, 0.2,\n    0.7, 0.3\n),nrow = 3, ncol = 2)\n\n## 2) area under\n## the precision-recall curve\nSLmetrics::pr.auc(\n    actual   = actual,\n    response = response\n)\n#>   Class A   Class B \n#> 0.4166667 1.0000000\n```\n\n#### Metric tools\n\nA new family of `Tools`-functions are introduced with this update. This\naddition introduces unexported functions for constructing fast and\nmemory efficient proprietary metrics. These functions are rewritten\nbuilt-in functions from {stats} and family.\n\n- **Covariance Matrix:** A re-written `stats::cov.wt()`, using `Rcpp`.\n  Example usage:\n\n``` r\n## 1) actual and\n## predicted values\nactual    <- c(1.2,  0.3, 0.56, 0.11, 1.01)\npredicted <- c(0.9, 0.22, 0.76, 0.21, 1.1) \n\n## 2) covariance\n## matrix \nSLmetrics:::cov.wt(\n    cbind(actual, predicted)\n)\n#> $cov\n#>             actual predicted\n#> actual    0.213330  0.169215\n#> predicted 0.169215  0.163720\n#> \n#> $center\n#>    actual predicted \n#>     0.636     0.638 \n#> \n#> $n.obs\n#> [1] 5\n```\n\n- **Area under the curve (AUC):** The function calculates the area under\n  the plot for bivariate curves for ordered and unordered `x` and `y`\n  pairs. The function assumes that values are ordered and calculates the\n  AUC directly - to control this behaviour use the `ordered`-argument in\n  the function. Below is an example:\n\n``` r\n## 0) seed\nset.seed(1903)\n\n## 1) Ordered x and y pair\nx <- seq(0, pi, length.out = 200)\ny <- sin(x)\n\n## 1.1) calculate area\nordered_auc <- SLmetrics::auc(y = y,  x = x)\n\n## 2) Unordered x and y pair\nx <- sample(seq(0, pi, length.out = 200))\ny <- sin(x)\n\n## 2.1) calculate area\nunordered_auc <- SLmetrics::auc(y = y,  x = x)\n\n## 2.2) calculate area with explicit\n## ordering\nunordered_auc_flag <- SLmetrics::auc(\n  y = y,\n  x = x,\n  ordered = FALSE\n)\n\n## 3) display result\ncat(\n  \"AUC (ordered x and y pair)\", ordered_auc,\n  \"AUC (unordered x and y pair)\", unordered_auc,\n  \"AUC (unordered x and y pair, with unordered flag)\", unordered_auc_flag,\n  sep = \"\\n\"\n)\n#> AUC (ordered x and y pair)\n#> 1.999958\n#> AUC (unordered x and y pair)\n#> -1.720771\n#> AUC (unordered x and y pair, with unordered flag)\n#> -1.720771\n```\n\n- **Sorting algorithms:** A set of sorting and ordering algorithms\n  applicable to matrices have been implemented. The use-case is\n  currently limited to `auc.foo`, `ROC` and `prROC` functions. The\n  algorithms can be used as follows:\n\n``` r\n## 1) generate a 4x4 matrix\n## with random values to be sorted\nset.seed(1903)\nX <- matrix(\n  data = cbind(sample(16:1)),\n  nrow = 4\n)\n\n## 2) sort matrix\n## in decreasing order\nSLmetrics::presort(X)\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    3    2    6    1\n#> [2,]    4    5   10    7\n#> [3,]    9    8   15   11\n#> [4,]   13   14   16   12\n\n## 3) get indices \n## for sorted matrix\nSLmetrics::preorder(X)\n#>      [,1] [,2] [,3] [,4]\n#> [1,]    1    1    2    4\n#> [2,]    2    3    3    2\n#> [3,]    3    2    1    1\n#> [4,]    4    4    4    3\n```\n\n## :boom: Breaking changes\n\n- **Logloss:** The argument `pk` has been replaced by `response`.\n\n\n\n\n# :bookmark: Version 0.3-2\n\n## :sparkles: Improvements\n\n- **Regression metrics (See PR\n  https://github.com/serkor1/SLmetrics/pull/64):** All regression\n  metrics have had their back-end optimized and are now 2-10 times\n  faster than prior versions.\n- **LAPACK/BLAS Support\n  (https://github.com/serkor1/SLmetrics/pull/65):** Added LAPACK/BLAS\n  support for efficient matrix-operations.\n- **OpenMP:** Enabling/disabling OpenMP is now handled on the `R`-side\n  and obeys `suppressMessages()`. See below:\n\n``` r\n## suppress OpenMP messages\nsuppressMessages(\n  SLmetrics::openmp.off()\n)\n```\n\n### :rocket: New features\n\n- **Available threads:** The available number of threads can be\n  retrieved using the `openmp.threads()`. See below:\n\n``` r\n## number of available\n## threads\nSLmetrics::openmp.threads()\n#> [1] 24\n```\n\n## :bug: Bug-fixes\n\n- **Diagnostic Odds Ratio:** The `dor()` is now returning a single\n  `<[numeric]>`-value instead of `k` number of identical\n  `<[numeric]>`-values.\n\n## :boom: Breaking Changes\n\n- **OpenMP Interface:** The interface to enabling/disabling OpenMP\n  support has been reworked and has a more natural flow. The new\n  interface is described below:\n\n``` r\n## enable OpenMP\nSLmetrics::openmp.on()\n#> OpenMP enabled!\n```\n\n``` r\n## disable OpenMP\nSLmetrics::openmp.off()\n#> OpenMP disabled!\n```\n\nTo set the number of threads use the `openmp.threads()` as follows:\n\n``` r\n## set number of threads\nSLmetrics::openmp.threads(3)\n#> Using 3 threads.\n```\n\n\n\n\n# :bookmark: Version 0.3-1\n\n## :sparkles: Improvements\n\n- **OpenMP Support (PR https://github.com/serkor1/SLmetrics/pull/40):**\n  {SLmetrics} now supports parallelization through OpenMP. The OpenMP\n  can be utilized as follows:\n\n``` r\nset.seed(1903)\n\n## 1) probability distribution\n## function\nrand.sum <- function(n){\n    x <- sort(runif(n-1))\n    c(x,1) - c(0,x)\n  }\n\n## 2) generate probability\n## matrix\npk <- t(replicate(\n    n = 100,\n    expr = rand.sum(1e3)\n    )\n)\n\n## 3) calulate entropy\n## with and without OpenMP\nSLmetrics::setUseOpenMP(TRUE)\n#> OpenMP usage set to: enabled\nsystem.time(SLmetrics::entropy(pk))\n#>    user  system elapsed \n#>   0.009   0.004   0.001\n\nSLmetrics::setUseOpenMP(FALSE)\n#> OpenMP usage set to: disabled\nsystem.time(SLmetrics::entropy(pk))\n#>    user  system elapsed \n#>   0.001   0.000   0.001\n```\n\n- **Entropy with soft labels\n  (https://github.com/serkor1/SLmetrics/issues/37):** `entropy()`,\n  `cross.entropy()` and `relative.entropy()` have been introduced. These\n  functions are heavily inspired by {scipy}. The functions can be used\n  as follows:\n\n``` r\n## 1) Define actual\n## and observed probabilities\n\n## 1.1) actual probabilies\npk <- matrix(\n  cbind(1/2, 1/2),\n  ncol = 2\n)\n\n## 1.2) observed (estimated) probabilites\nqk <- matrix(\n  cbind(9/10, 1/10), \n  ncol = 2\n)\n\n## 2) calculate entropy\ncat(\n  \"Entropy\", SLmetrics::entropy(pk),\n  \"Relative Entropy\", SLmetrics::relative.entropy(pk, qk),\n  \"Cross Entropy\", SLmetrics::cross.entropy(pk, qk),\n  sep = \"\\n\"\n)\n#> Entropy\n#> 0.6931472\n#> Relative Entropy\n#> 0.5108256\n#> Cross Entropy\n#> 1.203973\n```\n\n## :boom: Breaking changes\n\n- **logloss:** The argument `response` have ben renamed to `qk` as in\n  the `entropy()`-family to maintain some degree of consistency.\n- **entropy.factor():** The function have been deleted and is no more.\n  This was mainly due to avoid the documentation from being too large.\n  The `logloss()`-function replaces it.\n\n## :bug: Bug-fixes\n\n- **Plot-method in ROC and prROC\n  (https://github.com/serkor1/SLmetrics/issues/36):** Fixed a bug in\n  `plot.ROC()` and `plot.prROC()` where if `panels = FALSE` additional\n  lines would be added to the plot.\n\n\n\n\n# :bookmark: Version 0.3-0\n\n## :sparkles: Improvements\n\n### New features\n\n- **Relative Root Mean Squared Error:** The function normalizes the Root\n  Mean Squared Error by a factor. There is no official way of\n  normalizing it - and in {SLmetrics} the RMSE can be normalized using\n  three options; mean-, range- and IQR-normalization. It can be used as\n  follows,\n\n``` r\n## 1) define actual and\n## predicted values\nactual <- rnorm(50)\npredicted <- actual + rnorm(50)\n\n## 2) calculate rrse\n## with normalization\n## 0: mean\n## 1: range\n## 2: iqr\ncat(\n  \"Mean Relative Root Mean Squared Error\", SLmetrics::rrmse(\n    actual        = actual,\n    predicted     = predicted,\n    normalization = 0\n  ),\n  \"Range Relative Root Mean Squared Error\", SLmetrics::rrmse(\n    actual        = actual,\n    predicted     = predicted,\n    normalization = 1\n  ),\n  \"IQR Relative Root Mean Squared Error\", SLmetrics::rrmse(\n    actual        = actual,\n    predicted     = predicted,\n    normalization = 2\n  ),\n  sep = \"\\n\"\n)\n#> Mean Relative Root Mean Squared Error\n#> 8.784975\n#> Range Relative Root Mean Squared Error\n#> 0.1951562\n#> IQR Relative Root Mean Squared Error\n#> 0.5694271\n```\n\n- **Log Loss:** Weighted and unweighted Log Loss, with and without\n  normalization. The function can be used as follows,\n\n``` r\n## 1) define actual\n## values and estimated\n## probabilities\nactual   <- factor(c(\"Class A\", \"Class B\", \"Class A\"))\nweights  <- c(0.3,0.9,1) \nresponse <- matrix(cbind(\n    0.2, 0.8,\n    0.8, 0.2,\n    0.7, 0.3\n),nrow = 3, ncol = 2)\n\n## 2) weighted and unweighted\n## log-loss\ncat(\n    \"Unweighted Log Loss:\",\n    SLmetrics::logloss(\n        actual,\n        response\n    ),\n    \"Weighted log Loss:\",\n    SLmetrics::weighted.logloss(\n        actual,\n        response,       \n        weights\n    ),\n    sep = \"\\n\"\n)\n#> Unweighted Log Loss:\n#> 0.7297521\n#> Weighted log Loss:\n#> 0.4668102\n```\n\n- **Weighted Receiver Operator Characteristics:** `weighted.ROC()`, the\n  function calculates the weighted True Positive and False Positive\n  Rates for each threshold.\n\n- **Weighted Precision-Recall Curve:** `weighted.prROC()`, the function\n  calculates the weighted Recall and Precision for each threshold.\n\n## :boom: Breaking Changes\n\n- **Weighted Confusion Matrix:** The `w`-argument in `cmatrix()` has\n  been removed in favor of the more verbose weighted confusion matrix\n  call `weighted.cmatrix()`-function. See below,\n\nPrior to version `0.3-0` the weighted confusion matrix were a part of\nthe `cmatrix()`-function and were called as follows,\n\n``` r\nSLmetrics::cmatrix(\n    actual    = actual,\n    predicted = predicted,\n    w         = weights\n)\n```\n\nThis solution, although simple, were inconsistent with the remaining\nimplementation of weighted metrics in {SLmetrics}. To regain consistency\nand simplicity the weighted confusion matrix are now retrieved as\nfollows,\n\n``` r\n## 1) define actual\n## and predicted values\n## with sample weights\nactual    <- factor(sample(letters[1:3], 50, replace = TRUE))\npredicted <- factor(sample(letters[1:3], 50, replace = TRUE))\nweights   <- runif(length(actual))\n\n## 2) unweighted confusion\n## matrix\nSLmetrics::cmatrix(\n    actual    = actual,\n    predicted = predicted\n)\n#>   a b c\n#> a 5 8 4\n#> b 5 7 2\n#> c 9 6 4\n\n## 3) weighted confusion\n## matrix\nSLmetrics::weighted.cmatrix(\n    actual    = actual,\n    predicted = predicted,\n    w         = weights\n)\n#>          a        b        c\n#> a 2.322289 2.454870 1.638391\n#> b 2.766585 4.259595 0.550205\n#> c 3.620850 3.732882 2.151884\n```\n\n## :bug: Bug-fixes\n\n- **Return named vectors:** The classification metrics when\n  `micro == NULL` were not returning named vectors. This has been fixed.\n\n\n\n\n# :bookmark: Version 0.2-0\n\n## :hammer_and_wrench: General\n\n- **documentation:** The documentation has gotten some extra love, and\n  now all functions have their formulas embedded, the details section\n  have been freed from a general description of \\[factor\\] creation.\n  This will make room for future expansions on the various functions\n  where more details are required.\n\n- **Unit-testing:** All functions are now being tested for edge-cases in\n  balanced and imbalanced classification problems, and regression\n  problems, individually. This will enable a more robust development\n  process and prevent avoidable bugs.\n\n## :sparkles: Improvements\n\n- **weighted classification metrics:** The `cmatrix()`-function now\n  accepts the argument `w` which is the sample weights; if passed the\n  respective method will return the weighted metric. Below is an example\n  using sample weights for the confusion matrix,\n\n``` r\n## 1) define actual and \n## predicted values with\n## sample weights\nactual    <- factor(sample(letters[1:3], 50, replace = TRUE))\npredicted <- factor(sample(letters[1:3], 50, replace = TRUE))\nweights   <- runif(length(actual))\n\n## 2) compute weighted\n## and unweighted confusion\n## matrix\nSLmetrics::cmatrix(\n    actual    = actual,\n    predicted = predicted\n)\n#>   a b c\n#> a 7 4 5\n#> b 3 8 5\n#> c 9 4 5\n\nSLmetrics::cmatrix(\n    actual    = actual,\n    predicted = predicted,\n    w         = weights\n)\n#>          a        b        c\n#> a 3.834480 1.594902 2.070598\n#> b 2.100894 3.949499 1.813142\n#> c 4.363751 2.002751 2.396716\n```\n\nCalculating weighted metrics using the `<factor>`- or\n`<cmatrix>`-method,\n\n``` r\n## 1) weigthed confusion matrix\n## and weighted accuray\nconfusion_matrix <- SLmetrics::cmatrix(\n    actual    = actual,\n    predicted = predicted,\n    w         = weights\n)\n\n## 2) weighted accuracy\n## using <cmatrix> method\nSLmetrics::accuracy(\n    confusion_matrix\n)\n#> [1] 0.4219674\n\n## 2) weighted accuracy\n## using <factor> method\nSLmetrics::weighted.accuracy(\n    actual    = actual,\n    predicted = predicted,\n    w         = weights\n)\n#> [1] 0.4219674\n```\n\nPlease note, however, that it is not possible to pass `cmatrix()`-into\n`weighted.accuracy()`. See below:\n\n``` r\ntry(\n    SLmetrics::weighted.accuracy(\n        confusion_matrix\n    )\n)\n#> Error in UseMethod(generic = \"weighted.accuracy\", object = ..1) : \n#>   no applicable method for 'weighted.accuracy' applied to an object of class \"cmatrix\"\n```\n\n## :bug: Bug-fixes\n\n- **Floating precision:** Metrics would give different results based on\n  the method used. This means that `foo.cmatrix()` and `foo.factor()`\n  would produce different results (See Issue\n  https://github.com/serkor1/SLmetrics/issues/16). This has been fixed\n  by using higher precision `Rcpp::NumericMatrix` instead of\n  `Rcpp::IntegerMatrix`.\n\n- **Miscalculation of Confusion Matrix elements:** An error in how `FN`,\n  `TN`, `FP` and `TP` were calculated have been fixed. No issue has been\n  raised for this bug. This was not something that was caught by the\n  unit-tests, as the total samples were too high to spot this error. It\n  has, however, been fixed now. This means that all metrics that uses\n  these explicitly are now stable, and produces the desired output.\n\n- **Calculation Error in Fowlks Mallows Index:** A bug in the\n  calculation of the `fmi()`-function has been fixed. The\n  `fmi()`-function now correctly calculates the measure.\n\n- **Calculation Error in Pinball Deviance and Concordance Correlation\n  Coefficient:** See issue\n  https://github.com/serkor1/SLmetrics/issues/19. Switched to unbiased\n  variance calculation in `ccc()`-function. The `pinball()`-function\n  were missing a weighted quantile function. The issue is now fixed.\n\n- **Calculation Error in Balanced Accuracy:** See issue\n  https://github.com/serkor1/SLmetrics/issues/24. The function now\n  correctly adjusts for random chance, and the result matches that of\n  {scikit-learn}\n\n- **Calculation Error in F-beta Score:** See issue\n  https://github.com/serkor1/SLmetrics/issues/23. The function werent\n  respecting `na.rm` and `micro`, this has been fixed accordingly.\n\n- **Calculation Error in Relative Absolute Error:** The function was\n  incorrectly calculating means, instead of sums. This has been fixed.\n\n## :boom: Breaking changes\n\n- All regression metrics have had `na.rm`- and `w`-arguments removed.\n  All weighted regression metrics have a separate function on the\n  `weighted.foo()` to increase consistency across all metrics. The new\n  function call is given below:\n\n``` r\n## 1) define actual and\n## predicted values\nactual    <- rnorm(n = 50)\npredicted <- actual + rnorm(n = 50)\nw         <- runif(n = 50)\n\n## 2) weighted and unweighted\n## root mean squared error\nSLmetrics::rmse(actual, predicted)\n#> [1] 0.9705207\nSLmetrics::weighted.rmse(actual, predicted, w = w)\n#> [1] 0.9819614\n```\n\n- The `rrmse()`-function have been removed in favor of the\n  `rrse()`-function. This function was incorrectly specified and\n  described in the package.\n\n\n\n\n# :bookmark: Version 0.1-1\n\n## :hammer_and_wrench: General\n\n- **Backend changes:** All pair-wise metrics are moved from\n  [{Rcpp}](https://github.com/RcppCore/Rcpp) to `C++`, this have reduced\n  execution time by half. All pair-wise metrics are now faster.\n\n## :sparkles: Improvements\n\n- **NA-controls:** All pair-wise metrics that doesn’t have a\n  `micro`-argument were handling missing values as according to C++ and\n  {Rcpp} internals. See\n  [Issue](https://github.com/serkor1/SLmetrics/issues/8). Thank you\n  @EmilHvitfeldt for pointing this out. This has now been fixed so\n  functions uses an `na.rm`-argument to explicitly control for this. See\n  below,\n\n``` r\n## 1) define actual and\n## predicted classes\nactual    <- factor(c(\"no\", \"yes\", \"yes\"))\npredicted <- factor(c(NA, \"no\", \"yes\"))\n\n## 2) calculate\n## accuracy with\n## and without na.rm\nSLmetrics::accuracy(\n    actual    = actual,\n    predicted = predicted,\n    na.rm     = TRUE\n)\n#> [1] 0.5\n\nSLmetrics::accuracy(\n    actual    = actual,\n    predicted = predicted,\n    na.rm     = FALSE\n)\n#> [1] NaN\n```\n\n## :bug: Bug-fixes\n\n- The `plot.prROC()`- and `plot.ROC()`-functions now adds a line to the\n  plot when `panels = FALSE`. See Issue\n  https://github.com/serkor1/SLmetrics/issues/9.\n\n``` r\n## 1) define actual classes\n## and response probabilities\nactual <- factor(\n    sample(letters[1:3], size = 50, replace = TRUE)\n)\n\nresponse <- rbeta(\n    n = 50,\n    shape1 = 20,\n    shape2 = 2\n)\n\n## 2) define ROC and\n## prROC objects\nroc_obj <- SLmetrics::ROC(\n    actual   = actual,\n    response = response \n)\n\npr_obj <- SLmetrics::prROC(\n    actual   = actual,\n    response = response \n)\n```\n\n``` r\n## set plot grid\npar(mfrow = c(1,2))\n\n## plot data\n## with panels = FALSE\nplot(roc_obj, panels = FALSE)\n```\n\n<img src=\"v0.1-1_files/figure-commonmark/unnamed-chunk-4-1.png\"\nstyle=\"width:100.0%\" />\n\n``` r\nplot(pr_obj, panels = FALSE)\n```\n\n<img src=\"v0.1-1_files/figure-commonmark/unnamed-chunk-4-2.png\"\nstyle=\"width:100.0%\" />\n\n\n\n\n# :package: [{SLmetrics}](https://serkor1.github.io/SLmetrics/) Version 0.1-0\n\n[{SLmetrics}](https://serkor1.github.io/SLmetrics/) is a collection of\nMachine Learning performance evaluation functions for supervised\nlearning written in `C++`\nwith[{Rcpp}](https://github.com/RcppCore/Rcpp). Visit the online\ndocumentation on [Github pages](https://serkor1.github.io/SLmetrics/).\n\n## :information_source: Basic usage\n\n### Classification metrics\n\n``` r\n## 1) define actual and\n## predicted classes\nactual <- factor(\n    sample(letters[1:3], size = 10, replace = TRUE)\n)\n\npredicted <- factor(\n    sample(letters[1:3], size = 10, replace = TRUE)\n)\n\n## 2) print values\nprint(actual)\n#>  [1] b a a b a a c b c c\n#> Levels: a b c\n```\n\n``` r\n## 1) compute and summarise the\n## the confusion matrix\nsummary(\n    confusion_matrix <- SLmetrics::cmatrix(\n        actual    = actual,\n        predicted = predicted\n    )\n)\n#> Confusion Matrix (3 x 3) \n#> ================================================================================\n#>   a b c\n#> a 2 1 1\n#> b 1 2 0\n#> c 0 1 2\n#> ================================================================================\n#> Overall Statistics (micro average)\n#>  - Accuracy:          0.60\n#>  - Balanced Accuracy: 0.61\n#>  - Sensitivity:       0.60\n#>  - Specificity:       0.80\n#>  - Precision:         0.60\n```\n\n``` r\n## 1) false positive rate\n## using <cmatrix> method\nSLmetrics::fpr(confusion_matrix)\n#>         a         b         c \n#> 0.1666667 0.2857143 0.1428571\n\n## 2) false positive rate\n## using <factor> method\nSLmetrics::fpr(\n    actual    = actual, \n    predicted = predicted\n)\n#>         a         b         c \n#> 0.1666667 0.2857143 0.1428571\n```\n\n### Regression metrics\n\n``` r\n## 1) define actual and\n## predicted values\nactual <- rnorm(n = 10)\npredicted <- actual + rnorm(n = 10)\n```\n\n``` r\n## 1) calculate Huber Loss and\n## Root Mean Squared Error\nSLmetrics::huberloss(\n    actual    = actual,\n    predicted = predicted\n)\n#> [1] 0.3963274\n\nSLmetrics::rmse(\n    actual    = actual,\n    predicted = predicted\n)\n#> [1] 0.9120952\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}