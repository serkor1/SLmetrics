[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{SLmetrics}: Machine Learning Performance Evaluation on Steroids",
    "section": "",
    "text": "Preface\n{SLmetrics} started as a personal project to learn C++, and was never really meant to be published nor, infact, named {SLmetrics}. But as time went by, and the committed time and commits grew the name stayed, and the goal to publish a functioning data science R package seemed like the natural next step.\nThe primary goal of {SLmetrics} is to be a fast, memory efficient and reliable low-level successor to {MLmetrics}; and the current benchmarks in 3  Benchmarking suggets that this goal, in fact, have been achieved.\n\n\n\n\n\n\nWarning\n\n\n\n{SLmetrics} and the documentation is currently under development",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 The status-quo of {pkgs}\nThere are currently three {pkgs} that are developed with machine leaning performance evaluation in mind: {MLmetrics}, {yardstick}, {mlr3measures}. These {pkgs} have historically bridged the gap between R and Python in terms of machine learning and data science.\n{MLmetrics} can be considered the legacy code when it comes to performance evaluation, and it served as a backend in {yardstick} up to version 0.0.2. It is built entirely on base R, and has been stable since its inception almost 10 years ago.\nHowever, it appears that the development has reached it’s peak and is currently stale - see, for example, this stale PR related to this issue. Micro- and macro-averages have been implented in {scikit-learn} for many years, and {MLmetrics} simply didn’t keep up with the development.\n{yardstick}, on the other hand, carried the torch forward and implemented these modern features. {yardstick} closely follows the syntax, naming and functionality of {scikit-learn} but is built with {tidyverse} tools; although the source code is nice to look at, it does introduce some serious overhead and carries the risk of deprecations.\nFurthermore, it complicates a simple application by its verbose function naming, see for example metric()-function for &lt;tbl&gt; and metric_vec()-function for &lt;numeric&gt; - the output is the same, but the call is different. {yardstick} can’t handle more than one positive class at a time, so the end-user is forced to run the same function more than once to get performance metrics for the adjacent classes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#the-status-quo-of-pkgs",
    "href": "intro.html#the-status-quo-of-pkgs",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1.1 Summary\nIn short, the existing {pkgs} are outdated, inefficient and insufficient for modern large-scale machine learning applications.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#why-slmetrics",
    "href": "intro.html#why-slmetrics",
    "title": "1  Introduction",
    "section": "1.2 Why {SLmetrics}?",
    "text": "1.2 Why {SLmetrics}?\nAs the name suggests, {SLmetrics} closely resembles {MLmetrics} in it’s simplistic and low-level implementation of machine learning metrics. The resemblance ends there, however.\n{SLmetrics} are developed with three things in mind: speed, efficiency and scalability. And therefore addresses the shortcomings of the status-quo by construction - the {pkg} is built on c++ and {Rcpp} from the ground up. See Table 1.1 where\n\nCode\nset.seed(1903)\nactual &lt;- rnorm(1e7)\npredicted &lt;- actual + rnorm(1e7)\n\nbench::mark(\n    `{SLmetrics}` = SLmetrics::rmse(actual, predicted),\n    `{MLmetrics}` = MLmetrics::RMSE(predicted, actual),\n    iterations    = 100\n)\n\n\n\n\nTable 1.1: Calculating RMSE on 1e7 vectors\n\n\n\n# A tibble: 2 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 {SLmetrics}     30ms   30.6ms      32.1    6.13MB      0  \n2 {MLmetrics}   61.4ms   61.8ms      16.2   76.39MB     78.9\n\n\n\n\nThis shows that well-written R-code is hard to beat speed-wise. {MLmetrics} is roughly 20% faster - but uses 30,000 times more memory. How about constructing a confusion matrix\n\nCode\nset.seed(1903)\nactual &lt;- factor(sample(letters[1:3], size = 1e7, replace = TRUE))\npredicted &lt;- factor(sample(letters[1:3], size = 1e7, replace = TRUE))\n\nbench::mark(\n    `{SLmetrics}` = SLmetrics::cmatrix(actual, predicted),\n    `{MLmetrics}` = MLmetrics::ConfusionMatrix(actual, predicted),\n    check         = FALSE,\n    iterations    = 100\n)\n\n\n\n\nTable 1.2: Computing a 3x3 confusion matrix on 1e7 vectors\n\n\n\n# A tibble: 2 × 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt;  &lt;bch:tm&gt; &lt;bch:tm&gt;     &lt;dbl&gt; &lt;bch:byt&gt;    &lt;dbl&gt;\n1 {SLmetrics}   8.53ms   8.56ms    116.      4.12KB     0   \n2 {MLmetrics} 246.66ms 251.87ms      3.68   381.6MB     7.59\n\n\n\n\n{SLmetrics} uses 1/50th of the time {MLmetrics} and the memory usage is equivalent as the previous example but uses significantly less memory than {MLmetrics}.\n\n1.2.1 Summary\n{SLmetrics} is, in the worst-case scenario, on par with low-level R implementations of equivalent metrics and is a multitude more memory-efficient than any of the {pkgs}. A detailed benchmark can be found here.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#key-takeaways",
    "href": "intro.html#key-takeaways",
    "title": "1  Introduction",
    "section": "1.3 Key takeaways",
    "text": "1.3 Key takeaways",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "2.1 Basic Usage",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "summary.html#installation",
    "href": "summary.html#installation",
    "title": "2  Summary",
    "section": "2.2 Installation",
    "text": "2.2 Installation\n\n2.2.1 Stable version\n\n## install stable release\ndevtools::install_github(\n  repo = 'https://github.com/serkor1/SLmetrics@*release',\n  ref  = 'main'\n)\n\n\n\n2.2.2 Development version\n\n## install development version\ndevtools::install_github(\n  repo = 'https://github.com/serkor1/SLmetrics',\n  ref  = 'development'\n)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "benchmark.html",
    "href": "benchmark.html",
    "title": "3  Benchmarking",
    "section": "",
    "text": "3.1 The setup\nIn this section a detailed benchmark of {SLmetrics} is conducted. The benchmarks will be conducted on randomly selected functions, and then compared to {pkg} discussed in Chapter 1. The benchmarks are conducted on three parameters: median execution time, memory usage and gc() calls.\nThis section strucutred as follows, Section 3.1 sets up the infrastructure needed to conduct the benchmark in an unbiased way, in Section 3.2 the benchmarks are conducted and discussed and summarized in Section 3.3 and Section 3.4 respectively.\nTo conduct the benchmarking two functions are defined. create_regression() and create_factor(), both functions returns a vector of actual and predicted values with a length of 10,000,000 rows.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Benchmarking</span>"
    ]
  },
  {
    "objectID": "benchmark.html#sec-bench-setup",
    "href": "benchmark.html#sec-bench-setup",
    "title": "3  Benchmarking",
    "section": "",
    "text": "3.1.1 Regression problems\nThe benchmarks on regression metrics is conducted on correlated absolute value &lt;numeric&gt;-vectors, with uniformly distributed weights. create_regression() returns a named list, and is defined below:\n\n# regression function\ncreate_regression &lt;- function(\n    n = 1e7) {\n\n  # 1) actual\n  # values\n  actual &lt;- abs(rnorm(n = n))\n\n  # 2) predicted\n  # values\n  predicted &lt;- actual + abs(rnorm(n = n))\n\n  # 3) generate\n  # weights\n  w &lt;- runif(n)\n\n  list(\n    actual    = actual,\n    predicted = predicted,\n    w         = w\n  )\n}\n\n\n\n3.1.2 Classification problems\nThe benchmarks on classification metrics is conducted on the randomly sampled letters c(\"a\", \"b\", \"c\"). create_regression() returns a vector of &lt;factor&gt;, and is defined below:\n\n# classification function\ncreate_factor &lt;- function(\n    k = 3,\n    balanced = TRUE,\n    n = 1e7) {\n\n  probs &lt;- NULL\n\n  if (!balanced) {\n\n    probs &lt;- rbeta(\n      n = k,\n      shape1 = 10,\n      shape2 = 2\n    )\n\n    probs[which.min(probs)] &lt;- 0\n\n    probs &lt;- probs / sum(probs)\n\n  }\n\n  factor(\n    x = sample(\n      1:k,\n      size = n,\n      replace = TRUE,\n      prob = probs\n    ),\n    labels = letters[1:k],\n    levels = 1:k\n  )\n}\n\n\n\n3.1.3 Staging the testing ground\nThe vectors used in the benchmarks are created with the seed 1903 for reproducibility, see below:\n\n# 1) set seed for reproducibility\nset.seed(1903)\n\n# 2) create classification\n# problem\nfct_actual &lt;- create_factor()\nfct_predicted &lt;- create_factor()\n\n# 3) create regression\n# problem\n\n# 3.1) store results\n# in regression\nlst_regression &lt;- create_regression()\n\n# 3.2) assign the values\n# accordingly\nnum_actual &lt;- lst_regression$actual\nnum_predicted &lt;- lst_regression$predicted\nnum_weights &lt;- lst_regression$w",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Benchmarking</span>"
    ]
  },
  {
    "objectID": "benchmark.html#sec-bench-mark",
    "href": "benchmark.html#sec-bench-mark",
    "title": "3  Benchmarking",
    "section": "3.2 Benchmarking",
    "text": "3.2 Benchmarking\nTo conduct the benchmark {bench} is used. Before the benchmarks are conducted, a benchmark()-wrapper is created.\nThis wrapper conducts m (Default: 10) benchmarks, with 10 iterations for each benchmarked function passed into benchmark() - to allow for warm-up the first iteration is discarded. The wrapper is defined as follows:\n\nbenchmark &lt;- function(\n  ..., \n  m = 10) {\n  library(magrittr)\n  # 1) create list\n  # for storing values\n  performance &lt;- list()\n  \n  for (i in 1:m) {\n\n     # 1) run the benchmarks\n    results &lt;- bench::mark(\n      ...,\n      iterations = 10,\n      check = FALSE\n    )\n\n    # 2) extract values\n    # and calculate medians\n    performance$time[[i]]  &lt;- setNames(lapply(results$time, mean), results$expression)\n    performance$memory[[i]] &lt;- setNames(lapply(results$memory, function(x) { sum(x$bytes, na.rm = TRUE)}), results$expression)\n    performance$n_gc[[i]] &lt;- setNames(lapply(results$n_gc, sum), results$expression)\n\n  }\n\n  purrr::pmap_dfr(\n  list(performance$time, performance$memory, performance$n_gc), \n  ~{\n    tibble::tibble(\n      expression = names(..1),\n      time = unlist(..1),\n      memory = unlist(..2),\n      n_gc = unlist(..3)\n    )\n  }\n) %&gt;%\n  dplyr::mutate(expression = factor(expression, levels = unique(expression))) %&gt;%\n  dplyr::group_by(expression) %&gt;%\n  dplyr::filter(dplyr::row_number() &gt; 1) %&gt;%\n  dplyr::summarize(\n    execution_time = bench::as_bench_time(median(time)),\n    memory_usage = bench::as_bench_bytes(median(memory)),\n    gc_calls = median(n_gc),\n    .groups = \"drop\"\n  )\n\n}\n\n\n3.2.1 Regression metrics\n\nCode\nbenchmark(\n    `{RMSE}`  = SLmetrics::rmse(num_actual, num_predicted),\n    `{Pinball Loss}` = SLmetrics::pinball(num_actual, num_predicted),\n    `{Huber Loss}` = SLmetrics::huberloss(num_actual, num_predicted)\n)\n\n\n\n\nTable 3.1: Benchmarking selected regression metrics\n\n\n\n#&gt; # A tibble: 3 × 4\n#&gt;   expression     execution_time memory_usage gc_calls\n#&gt;   &lt;fct&gt;                &lt;bch:tm&gt;    &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 {RMSE}                 30.3ms           0B        0\n#&gt; 2 {Pinball Loss}         30.1ms           0B        0\n#&gt; 3 {Huber Loss}             75ms           0B        0\n\n\n\n\n\nCode\nbenchmark(\n    `{SLmetrics}` = SLmetrics::rmse(num_actual, num_predicted),\n    `{MLmetrics}` = MLmetrics::RMSE(num_actual, num_predicted),\n    `{yardstick}` = yardstick::rmse_vec(num_actual, num_predicted),\n    `{mlr3measures}` = mlr3measures::rmse(num_actual, num_predicted)\n)\n\n\n\n\nTable 3.2: Benchmarking RMSE across\n\n\n\n#&gt; # A tibble: 4 × 4\n#&gt;   expression     execution_time memory_usage gc_calls\n#&gt;   &lt;fct&gt;                &lt;bch:tm&gt;    &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 {SLmetrics}            30.5ms           0B        0\n#&gt; 2 {MLmetrics}            61.8ms       76.3MB        1\n#&gt; 3 {yardstick}           170.7ms      419.6MB       10\n#&gt; 4 {mlr3measures}         86.7ms       76.3MB        1\n\n\n\n\n\n\n3.2.2 Classification metrics\n\nCode\nbenchmark(\n    `{Confusion Matrix}`  = SLmetrics::cmatrix(fct_actual, fct_predicted),\n    `{Accuracy}` = SLmetrics::accuracy(fct_actual, fct_predicted),\n    `{F-beta}` = SLmetrics::fbeta(fct_actual, fct_predicted)\n)\n\n\n\n\nTable 3.3: Benchmarking selected classification metrics\n\n\n\n#&gt; # A tibble: 3 × 4\n#&gt;   expression         execution_time memory_usage gc_calls\n#&gt;   &lt;fct&gt;                    &lt;bch:tm&gt;    &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 {Confusion Matrix}         8.57ms           0B        0\n#&gt; 2 {Accuracy}                 8.57ms           0B        0\n#&gt; 3 {F-beta}                   8.58ms           0B        0\n\n\n\n\n\nCode\nbenchmark(\n    `{SLmetrics}`    = SLmetrics::cmatrix(fct_actual, fct_predicted),\n    `{MLmetrics}`    = MLmetrics::ConfusionMatrix(fct_predicted, fct_actual),\n    `{yardstick}`    = yardstick::conf_mat(table(fct_actual, fct_predicted))\n)\n\n\n\n\nTable 3.4: Benchmarking a 3x3 confusion matrix across\n\n\n\n#&gt; # A tibble: 3 × 4\n#&gt;   expression  execution_time memory_usage gc_calls\n#&gt;   &lt;fct&gt;             &lt;bch:tm&gt;    &lt;bch:byt&gt;    &lt;dbl&gt;\n#&gt; 1 {SLmetrics}         8.56ms           0B        0\n#&gt; 2 {MLmetrics}       247.96ms        381MB        7\n#&gt; 3 {yardstick}       248.26ms        381MB        7",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Benchmarking</span>"
    ]
  },
  {
    "objectID": "benchmark.html#sec-bench-discussion",
    "href": "benchmark.html#sec-bench-discussion",
    "title": "3  Benchmarking",
    "section": "3.3 Discussion",
    "text": "3.3 Discussion\nDoes speed really matter at the milliseconds level, and justify the raîson d’être for {SLmetrics} - the answer is inevitably no. A reduction of a few milliseconds may marginally improve performance, perhaps shaving off minutes or hours in large-scale grid searches or multi-model experiments. While this might slightly reduce cloud expenses, the overall impact is often negligible unless you’re operating at an enormous scale or in latency-critical environments.\nHowever, the memory efficiency of {SLmetrics} is where its real value lies. Its near-zero RAM usage allows more memory to be allocated for valuable tasks, such as feeding larger datasets into models. This can directly lead to higher-performing models, as more data generally improves learning outcomes. Furthermore, by optimizing memory usage, {SLmetrics} can reduce infrastructure costs significantly, as less powerful machines or fewer cloud resources may be required to achieve the same — or better — results.\nIn short, while speed optimization may seem like a more visible metric, it’s the memory efficiency of {SLmetrics} that has a broader, more transformative impact on machine learning workflows, from enabling better model performance to substantial cost reductions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Benchmarking</span>"
    ]
  },
  {
    "objectID": "benchmark.html#sec-bench-conclusion",
    "href": "benchmark.html#sec-bench-conclusion",
    "title": "3  Benchmarking",
    "section": "3.4 Conclusion",
    "text": "3.4 Conclusion\nThe benchmarks conducted in Section 3.2 suggests that {SLmetrics} is the memory-efficient and fast alternative to {MLmetrics}, {yardstick} and {mlr3measures}.\nIn the worst performing benchmarks {SLmetrics} is on par with low-level implementations of equivalent metrics and is consistently more memory-efficient in all benchmarks.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Benchmarking</span>"
    ]
  }
]