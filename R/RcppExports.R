# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @rdname accuracy
#' @method accuracy factor
#'
#' @export
accuracy.factor <- function(actual, predicted, ...) {
    .Call(`_SLmetrics_accuracy`, actual, predicted)
}

#' @rdname accuracy
#' @method accuracy cmatrix
#'
#' @export
accuracy.cmatrix <- function(x, ...) {
    .Call(`_SLmetrics_accuracy_cmatrix`, x)
}

#' @rdname baccuracy
#' @method baccuracy factor
#'
#' @export
baccuracy.factor <- function(actual, predicted, adjust = FALSE, ...) {
    .Call(`_SLmetrics_baccuracy`, actual, predicted, adjust)
}

#' @rdname baccuracy
#' @method baccuracy cmatrix
#'
#' @export
baccuracy.cmatrix <- function(x, adjust = FALSE, ...) {
    .Call(`_SLmetrics_baccuracy_cmatrix`, x, adjust)
}

#' @rdname ckappa
#' @method ckappa factor
#'
#' @export
ckappa.factor <- function(actual, predicted, beta = 1.0, ...) {
    .Call(`_SLmetrics_ckappa`, actual, predicted, beta)
}

#' @rdname ckappa
#' @method ckappa cmatrix
#'
#' @export
ckappa.cmatrix <- function(x, beta = 1.0, ...) {
    .Call(`_SLmetrics_ckappa_cmatrix`, x, beta)
}

#' Confusion Matrix
#'
#' @description
#'
#' The [cmatrix()]-function uses cross-classifying factors to build
#' a confusion matrix of the counts at each combination of the [factor] levels.
#' Each row of the [matrix] represents the actual [factor] levels, while each
#' column represents the predicted [factor] levels.
#'
#' @usage
#' cmatrix(
#'   actual,
#'   predicted
#' )
#'
#' @param actual A <[factor]>-vector of [length] \eqn{n}, and \eqn{k} levels.
#' @param predicted A <[factor]>-vector of [length] \eqn{n}, and \eqn{k} levels.
#'
#' @example man/examples/scr_confusionmatrix.R
#' @family classification
#'
#' @inherit specificity details
#'
#' @section Dimensions:
#'
#' There is no robust defensive measure against misspecififying
#' the confusion matrix. If the arguments are correctly specified, the resulting
#' confusion matrix is on the form:
#'
#' |            | A (Predicted) | B (Predicted) |
#' | :----------|:-------------:| -------------:|
#' | A (Actual) | Value         | Value         |
#' | B (Actual) | Value         | Value         |
#'
#'
#' @returns
#'
#' A named \eqn{k} x \eqn{k} <[matrix]> of [class] <cmatrix>
#'
#' @export
cmatrix <- function(actual, predicted) {
    .Call(`_SLmetrics_cmatrix`, actual, predicted)
}

#' @rdname dor
#'
#' @method dor factor
#' @export
dor.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_dor`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname dor
#'
#' @method dor cmatrix
#' @export
dor.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_dor_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname fbeta
#' @method fbeta factor
#'
#' @export
fbeta.factor <- function(actual, predicted, beta = 1.0, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fbeta`, actual, predicted, beta, micro, na_rm = na.rm)
}

#' @rdname fbeta
#' @method fbeta cmatrix
#'
#' @export
fbeta.cmatrix <- function(x, beta = 1.0, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fbeta_cmatrix`, x, beta, micro, na_rm = na.rm)
}

#' @rdname fdr
#' @method fdr factor
#'
#' @export
fdr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fdr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname fdr
#' @method fdr cmatrix
#'
#' @export
fdr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fdr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname fer
#' @method fer factor
#'
#' @export
fer.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fer`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname fer
#' @method fer cmatrix
#'
#' @export
fer.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fer_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname fpr
#' @method fpr factor
#'
#' @export
fpr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fpr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname fpr
#' @method fpr cmatrix
#'
#' @export
fpr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fpr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname fpr
#' @method fallout factor
#' @export
fallout.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fallout`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname fpr
#' @method fallout cmatrix
#' @export
fallout.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_fallout_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname fmi
#' @method fmi factor
#' @export
fmi.factor <- function(actual, predicted, ...) {
    .Call(`_SLmetrics_fmi`, actual, predicted)
}

#' @rdname fmi
#' @method fmi cmatrix
#' @export
fmi.cmatrix <- function(x, ...) {
    .Call(`_SLmetrics_fmi_cmatrix`, x)
}

#' @rdname jaccard
#' @method jaccard factor
#' @export
jaccard.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_jaccard`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname jaccard
#' @method jaccard cmatrix
#' @export
jaccard.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_jaccard_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname jaccard
#' @method csi factor
#' @export
csi.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_csi`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname jaccard
#' @method csi cmatrix
#' @export
csi.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_csi_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname jaccard
#' @method tscore factor
#' @export
tscore.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tscore`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname tscore
#' @method tscore cmatrix
#' @export
tscore.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tscore_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname mcc
#' @method mcc factor
#' @export
mcc.factor <- function(actual, predicted, ...) {
    .Call(`_SLmetrics_mcc`, actual, predicted)
}

#' @rdname mcc
#' @method mcc cmatrix
#' @export
mcc.cmatrix <- function(x, ...) {
    .Call(`_SLmetrics_mcc_cmatrix`, x)
}

#' @rdname mcc
#' @method phi factor
#' @export
phi.factor <- function(actual, predicted, ...) {
    .Call(`_SLmetrics_phi`, actual, predicted)
}

#' @rdname mcc
#' @method phi cmatrix
#' @export
phi.cmatrix <- function(x, ...) {
    .Call(`_SLmetrics_phi_cmatrix`, x)
}

#' @rdname nlr
#'
#' @method nlr factor
#' @export
nlr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_nlr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname nlr
#'
#' @method nlr cmatrix
#' @export
nlr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_nlr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname npv
#' @method npv factor
#'
#' @export
npv.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_npv`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname npv
#' @method npv cmatrix
#'
#' @export
npv.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_npv_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname plr
#'
#' @method plr factor
#' @export
plr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_plr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname plr
#'
#' @method plr cmatrix
#' @export
plr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_plr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname precision
#' @method precision factor
#'
#' @export
precision.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_precision`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname precision
#' @method precision cmatrix
#'
#' @export
precision.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_precision_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname precision
#' @method ppv factor
#'
#' @export
ppv.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_ppv`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname precision
#' @method ppv cmatrix
#'
#' @export
ppv.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_ppv_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname recall
#' @method recall factor
#'
#' @export
recall.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_recall`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname recall
#'
#' @method recall cmatrix
#' @export
recall.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_recall_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname recall
#' @method sensitivity factor
#'
#' @export
sensitivity.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_sensitivity`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname recall
#'
#' @method sensitivity cmatrix
#' @export
sensitivity.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_sensitivity_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname recall
#'
#' @method tpr factor
#' @export
tpr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tpr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname recall
#'
#' @method tpr cmatrix
#' @export
tpr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tpr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method specificity factor
#'
#' @export
specificity.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_specificity`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method specificity cmatrix
#'
#' @export
specificity.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_specificity_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method tnr factor
#'
#' @export
tnr.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tnr`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method tnr cmatrix
#'
#' @export
tnr.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_tnr_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method selectivity factor
#'
#' @export
selectivity.factor <- function(actual, predicted, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_selectivity`, actual, predicted, micro, na_rm = na.rm)
}

#' @rdname specificity
#' @method selectivity cmatrix
#'
#' @export
selectivity.cmatrix <- function(x, micro = NULL, na.rm = TRUE, ...) {
    .Call(`_SLmetrics_selectivity_cmatrix`, x, micro, na_rm = na.rm)
}

#' @rdname zerooneloss
#' @method zerooneloss factor
#' @export
zerooneloss.factor <- function(actual, predicted, ...) {
    .Call(`_SLmetrics_zerooneloss`, actual, predicted)
}

#' @rdname zerooneloss
#' @method zerooneloss cmatrix
#' @export
zerooneloss.cmatrix <- function(x, ...) {
    .Call(`_SLmetrics_zerooneloss_cmatrix`, x)
}

#' Compute the \eqn{R^2}
#'
#' @description
#' The [rsq()]-function calculates the \eqn{R^2}, the [coefficient of determination](https://en.wikipedia.org/wiki/Coefficient_of_determination), between the ovserved
#' and predicted <[numeric]> vectors. By default [rsq()] returns the unadjusted \eqn{R^2}. For adjusted \eqn{R^2} set \eqn{k = \kappa - 1}, where \eqn{\kappa} is the number of parameters.
#'
#' @usage
#' # `rsq()`-function
#' rsq(
#'   actual,
#'   predicted,
#'   k = 0
#' )
#'
#' @inherit huberloss
#' @param k A <[numeric]>-vector of [length] 1. 0 by default. If \eqn{k>0}
#' the function returns the adjusted \eqn{R^2}.
#'
#' @section Calculation:
#'
#' The metric is calculated as follows,
#'
#' \deqn{
#'   R^2 = 1 - \frac{\text{SSE}}{\text{SST}} \frac{n-1}{n - (k + 1)}
#' }
#'
#' Where \eqn{\text{SSE}} is the sum of squared errors, \eqn{\text{SST}} is total sum of squared errors, \eqn{n} is the number of observations, and \eqn{k} is the number of non-constant parameters.
#'
#' @family regression
#'
rsq <- function(actual, predicted, k = 0) {
    .Call(`_SLmetrics_rsq`, actual, predicted, k)
}

#' Compute the \eqn{\text{concordance correlation coefficient}}
#'
#' @description
#' The [ccc()]- and [wccc()]-function computes the simple and weighted [concordance correlation coefficient](https://en.wikipedia.org/wiki/Concordance_correlation_coefficient) between
#' the two vectors of predicted and observed <[numeric]> values.
#'
#' If `correction` is [TRUE] \eqn{\sigma^2} is adjusted by \eqn{\frac{1-n}{n}} in the intermediate steps.
#'
#' @usage
#' # `ccc()`-function
#' ccc(
#'   actual,
#'   predicted,
#'   correction = FALSE
#' )
#'
#' @inherit huberloss
#' @param correction A <[logical]> vector of [length] 1. [FALSE] by default. If [TRUE] the variance and covariance
#' will be adjusted with \eqn{\frac{1-n}{n}}
#'
#' @example man/examples/scr_ccc.R
#'
#' @section Calculation:
#'
#' The metric is calculated as follows,
#'
#' \deqn{
#'   \rho_c = \frac{2 \rho \sigma_x \sigma_y}{\sigma_x^2 + \sigma_y^2 + (\mu_x - \mu_y)^2}
#' }
#'
#' Where \eqn{\rho} is the \eqn{\text{pearson correlation coefficient}}, \eqn{\sigma} is the \eqn{\text{standard deviation}} and \eqn{\mu} is the simple mean of `actual` and `predicted`.
#'
#' If `w` is not [NULL], all calculations are based on the weighted measures.
#'
#' @family regression
#' @export
ccc <- function(actual, predicted, correction = FALSE) {
    .Call(`_SLmetrics_ccc`, actual, predicted, correction)
}

#' @rdname ccc
#'
#' @usage
#' # `wccc()`-function
#' wccc(
#'   actual,
#'   predicted,
#'   w,
#'   correction = FALSE
#' )
#'
#' @export
wccc <- function(actual, predicted, w, correction = FALSE) {
    .Call(`_SLmetrics_wccc`, actual, predicted, w, correction)
}

#' @rdname huberloss
#' @method huberloss numeric
#' @export
huberloss.numeric <- function(actual, predicted, delta = 1.0, w = NULL, ...) {
    .Call(`_SLmetrics_huberloss`, actual, predicted, delta, w)
}

#' Compute the \eqn{\text{mean absolute error}}
#'
#' The [mae()]- and [wmae()]-function computes the simple and weighted [mean absolute error](https://en.wikipedia.org/wiki/Mean_absolute_error) between
#' the observed and predicted <[numeric]> vectors. If `w` is not [NULL] the function returns the weighted mean absolute error.
#'
#' @usage
#' # `mae()`-function
#' mae(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @example man/examples/scr_mae.R
#'
#' @section Calculation:
#'
#' The metric is calulated as follows,
#'
#' \deqn{
#'   \frac{\sum_i^n |y_i - \upsilon_i|}{n}
#' }
#'
#' If \eqn{w} is not [NULL] the function returns the weigthed version.
#'
#' @family regression
#'
#' @export
mae <- function(actual, predicted) {
    .Call(`_SLmetrics_mae`, actual, predicted)
}

#' @rdname mae
#'
#' @usage
#' # `wmae()`-function
#' wmae(
#'   actual,
#'   predicted,
#'   w
#' )
#' @export
wmae <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmae`, actual, predicted, w)
}

#' Compute the \eqn{\text{mean absolute percentage error}}
#'
#' The [mape()]- and [wmape()]-function computes the simple and weighted [mean absolute percentage error](https://en.wikipedia.org/wiki/Mean_absolute_percentage_error) between
#' the observed and predicted <[numeric]> vectors. If `w` is not [NULL] the function returns the weighted mean absolute error.
#' @usage
#' # `mape()`-function
#' mape(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @example man/examples/scr_mape.R
#'
#' @section Calculation:
#'
#' The metric is calculated as,
#'
#' \deqn{
#'   \frac{1}{n} \sum_i^n \frac{|y_i - \upsilon_i|}{|y_i|}
#' }
#'
#' If \eqn{\text{w}} is not [NULL], the weighted version is calculated.
#'
#' @family regression
#' @export
mape <- function(actual, predicted) {
    .Call(`_SLmetrics_mape`, actual, predicted)
}

#' @rdname mape
#'
#' @usage
#' # `wmape()`-function
#' wmape(
#'   actual,
#'   predicted,
#'   w
#' )
#'
#' @export
wmape <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmape`, actual, predicted, w)
}

#' Compute the \eqn{\text{mean percentage error}}
#'
#' The [mpe()]-function computes the [mean percentage error](https://en.wikipedia.org/wiki/Mean_percentage_error) between
#' the observed and predicted <[numeric]> vectors. If `w` is not [NULL], the function returns the weighted mean percentage error.
#' @usage
#' # `mpe()`-function
#' mpe(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @example man/examples/scr_mpe.R
#'
#' @section Calculation:
#'
#' The metric is calculated as,
#'
#' \deqn{
#'   \frac{1}{n} \sum_i^n \frac{y_i - \upsilon_i}{y_i}
#' }
#'
#' Where \eqn{y_i} and \eqn{\upsilon_i} are the `actual` and `predicted` values respectively. If \eqn{\text{w}} is not [NULL], the weighted version is calculated.
#'
#' @family regression
#' @export
mpe <- function(actual, predicted) {
    .Call(`_SLmetrics_mpe`, actual, predicted)
}

#' @rdname mpe
#'
#' @usage
#' # `wmpe()`-function
#' wmpe(
#'   actual,
#'   predicted,
#'   w
#' )
#' @export
wmpe <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wmpe`, actual, predicted, w)
}

#' @rdname mse
#' @method mse numeric
#' @export
mse.numeric <- function(actual, predicted, w = NULL, ...) {
    .Call(`_SLmetrics_mse`, actual, predicted, w)
}

#' @rdname rmse
#' @method rmse numeric
#' @export
rmse.numeric <- function(actual, predicted, w = NULL, ...) {
    .Call(`_SLmetrics_rmse`, actual, predicted, w)
}

#' @rdname rmsle
#' @method rmsle numeric
#' @export
rmsle.numeric <- function(actual, predicted, w = NULL, ...) {
    .Call(`_SLmetrics_rmsle`, actual, predicted, w)
}

#' Compute the \eqn{\text{symmetric mean absolute percentage error}}
#'
#' The [smape()]- and [wsmape()]-function computes the simple and weighted [symmetric mean absolute percentage error](https://en.wikipedia.org/wiki/Symmetric_mean_absolute_percentage_error).
#'
#' @usage
#' # `smape()`-function
#' smape(
#'   actual,
#'   predicted
#' )
#'
#' @inherit huberloss
#'
#' @example man/examples/scr_smape.R
#'
#' @section Calculation:
#'
#' The metric is calculated as follows,
#'
#' \deqn{
#'   \sum_i^n \frac{1}{n} \frac{|y_i - \upsilon_i|}{\frac{|y_i|+|\upsilon_i|}{2}}
#' }
#'
#' where \eqn{y_i} and \eqn{\upsilon_i} is the `actual` and `predicted` values respectively. If `w` is not [NULL], the metric is calculated
#' using weights.
#'
#' @family regression
#' @export
smape <- function(actual, predicted) {
    .Call(`_SLmetrics_smape`, actual, predicted)
}

#' @rdname smape
#'
#' @usage
#' # `wsmape()`-function
#' wsmape(
#'   actual,
#'   predicted,
#'   w
#' )
#'
#' @export
wsmape <- function(actual, predicted, w) {
    .Call(`_SLmetrics_wsmape`, actual, predicted, w)
}

